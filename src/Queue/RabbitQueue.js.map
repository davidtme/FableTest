{"version":3,"sources":["RabbitQueue.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGK,sCAHL;;;KAGK;;AAGA,gDANL;;;;;;KAMK;;AAcO,wBACR;;;KADQ;;AAIA,yBACJ;AAAgB;;UAAyB,iCAAzB,EAAhB;;AACU;;UADV;AAEJ,gDAFI;AAGJ,sDAHI;AAIJ,sBAA2B;;SAA3B,EAJI;KADI;;AAOA,oBAAU;;AAClB,iCAAyC;;;;;SAAzC,EADkB;KAAV;;AAGR,gEACA;yBAAmB,6BAAnB,EAA+D;;SAA/D;KADA;;AAGA","file":"RabbitQueue.js","sourcesContent":["ï»¿module RabbitQueue\r\nopen System\r\n\r\ntype Message1 = \r\n    { Body : string }\r\n\r\ntype QueueSettings = \r\n    { UserName : string\r\n      Password : string\r\n      HostName : string\r\n      ExchangeName : string }\r\n\r\n#if FABLE\r\n\r\nopen Fable.Core\r\nopen Fable.Import\r\n\r\n[<Import(\"*\", \"amqplib/callback_api\")>]\r\nlet private AmqpLib : obj = failwith \"JS only\"\r\n\r\nlet private channelClosed connection error = \r\n    connection?close $ () |> ignore\r\n    ignore()\r\n\r\nlet private channelCreated (settings : QueueSettings, queueName : string, message) connection error channel = \r\n    let messageBuffer = createNew Node.Buffer $ (JS.JSON.stringify (message))\r\n    let options = createObj [ \"durable\" ==> true ]\r\n    channel?assertQueue $ (queueName, options) |> ignore\r\n    channel?sendToQueue $ (queueName, messageBuffer) |> ignore\r\n    channel?close $ (Func<_, _>(channelClosed connection)) |> ignore\r\n\r\nlet private connected a err connection = \r\n    connection?createChannel $ (Func<_, _, _>(channelCreated a connection)) |> ignore\r\n\r\nlet publishMessageToQueue settings message queueName = \r\n    AmqpLib?connect $ (\"amqp://\" + settings.HostName, Func<_, _, _>(connected (settings, queueName, message))) |> ignore\r\n\r\nlet subscribeToQueue queueName settings (handler : 'a -> unit) = \r\n    ignore()\r\n\r\n#else\r\n\r\nopen RabbitMQ.Client\r\nopen Newtonsoft.Json\r\nopen System.Text\r\nopen System.Threading\r\n\r\nlet private createConnection (settings : QueueSettings) = \r\n    let factory = ConnectionFactory()\r\n    factory.UserName <- settings.UserName\r\n    factory.Password <- settings.Password\r\n    factory.HostName <- settings.HostName\r\n    factory.CreateConnection()\r\n\r\nlet private createModel (connection : IConnection) (settings : QueueSettings) queueName = \r\n    let model = connection.CreateModel()\r\n    model.ExchangeDeclare(settings.ExchangeName, \"direct\", true)\r\n    let a = model.QueueDeclare(queueName, true, false, false, null)\r\n    model.QueueBind(queueName, settings.ExchangeName, queueName)\r\n    model\r\n\r\nlet subscribeToQueue queueName settings (handler : 'a -> unit) = \r\n    let cts = new CancellationTokenSource()\r\n    let wh = new AutoResetEvent(false)\r\n    async { \r\n        use connection = createConnection settings\r\n        use model = createModel connection settings queueName \r\n        model.BasicQos(0ul, 1us, false)\r\n        let consumer = QueueingBasicConsumer(model)\r\n        let a = model.BasicConsume(queueName, false, consumer)\r\n        let timeout = TimeSpan.FromSeconds(10.).TotalMilliseconds |> int\r\n        while not cts.IsCancellationRequested do\r\n            match consumer.Queue.Dequeue(timeout) with\r\n            | true, deliveryArgs -> \r\n                let json = Encoding.Default.GetString(deliveryArgs.Body)\r\n                let message = JsonConvert.DeserializeObject<'a>(json)\r\n                handler message\r\n                model.BasicAck(deliveryArgs.DeliveryTag, false)\r\n            | _ -> ignore()\r\n        wh.Set() |> ignore\r\n    }\r\n    |> Async.Start\r\n    fun () -> \r\n        cts.Cancel()\r\n        cts.Dispose()\r\n        wh.WaitOne() |> ignore\r\n\r\n\r\nlet publishMessageToQueue settings message queueName =\r\n    use connection = createConnection settings\r\n    use model = createModel connection settings queueName\r\n    let properties = model.CreateBasicProperties()\r\n    properties.Persistent <- true\r\n    let json = JsonConvert.SerializeObject(message)\r\n    let bytes = Encoding.Default.GetBytes(json)\r\n    model.BasicPublish(settings.ExchangeName, queueName, properties, bytes)\r\n\r\n#endif\r\n\r\nlet inline subscribe settings (handler : 'a -> unit) = \r\n    subscribeToQueue typeof<'a>.FullName settings handler\r\n\r\nlet inline publishMessage settings (message: 'a) = \r\n    publishMessageToQueue settings message typeof<'a>.FullName \r\n"]}